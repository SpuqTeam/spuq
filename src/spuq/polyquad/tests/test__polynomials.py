import numpy as np
from operator import add, mul
from itertools import imap

from spuq.utils.testing import *
from spuq.polyquad._polynomials import *


inner = lambda p, q: reduce(add, imap(mul, p, q))


"""Make sure the recurrence coefficients generate the right family of polynomials 
(coefficients for comparison usually taken from wikipedia or generated by mathematica)"""
def test_legendre():
    x = np.poly1d([1, 0])
    P = compute_poly(rc_legendre, 5, x)
    assert_array_equal(P[0].coeffs, [1])
    assert_array_equal(P[1].coeffs, np.array([1, 0]))
    assert_array_equal(P[2].coeffs, np.array([3, 0, -1]) / 2.0)
    assert_array_equal(P[3].coeffs, np.array([5, 0, -3, 0]) / 2.0)
    assert_array_equal(P[4].coeffs, np.array([35, 0, -30, 0, 3]) / 8.0)

def test_stoch_hermite():
    x = np.poly1d([1, 0])
    P = compute_poly(rc_stoch_hermite, 5, x)
    assert_array_equal(P[0].coeffs, [1])
    assert_array_equal(P[1].coeffs, np.array([1, 0]))
    assert_array_equal(P[2].coeffs, np.array([1, 0, -1]))
    assert_array_equal(P[3].coeffs, np.array([1, 0, -3, 0]))
    assert_array_equal(P[4].coeffs, np.array([1, 0, -6, 0, 3]))

def test_jacobi():
    x = np.poly1d([1, 0])
    rc_jac = lambda n: rc_jacobi(n, 0, 2)
    P = compute_poly(rc_jac, 5, x)
    assert_array_almost_equal(P[0].coeffs, [1])
    assert_array_almost_equal(P[1].coeffs, [2, -1])
    assert_array_almost_equal(P[2].coeffs, [3.75, -2.5, -0.25])
    assert_array_almost_equal(P[3].coeffs, [7, -5.25, -1.5, 0.75])


def test_chebyshev_t():
    x = np.poly1d([1, 0])
    P = compute_poly(rc_chebyshev_t, 5, x)
    assert_array_equal(P[0].coeffs, [1])
    assert_array_equal(P[1].coeffs, np.array([1, 0]))
    assert_array_equal(P[2].coeffs, np.array([2, 0, -1]))
    assert_array_equal(P[3].coeffs, np.array([4, 0, -3, 0]))
    assert_array_equal(P[4].coeffs, np.array([8, 0, -8, 0, 1]))


def test_chebyshev_u():
    x = np.poly1d([1, 0])
    P = compute_poly(rc_chebyshev_u, 5, x)
    assert_array_equal(P[0].coeffs, [1])
    assert_array_equal(P[1].coeffs, np.array([2, 0]))
    assert_array_equal(P[2].coeffs, np.array([4, 0, -1]))
    assert_array_equal(P[3].coeffs, np.array([8, 0, -4, 0]))
    assert_array_equal(P[4].coeffs, np.array([16, 0, -12, 0, 1]))


def test_monomials():
    x = np.poly1d([1, 0])
    P = compute_poly(rc_monomials, 5, x)
    assert_array_equal(P[4], x ** 4)


def test_sqnorm_legendre():
    # first test norm of legendre polynomials
    assert_almost_equal( sqnorm_legendre(0), 1.0)
    assert_almost_equal( sqnorm_legendre(1), 1.0/3.0)
    assert_almost_equal( sqnorm_legendre(2), 1.0/5.0)
    assert_almost_equal( sqnorm_legendre(3), 1.0/7.0)
    assert_almost_equal( sqnorm_legendre(4), 1.0/9.0)


def test_sqnorm_from_rc():
    # make sure the function to compute the norm of the orthogonal polys
    # from the recurrence coefficients generates the same values as those 
    # computed directly by some analytic formula. We do that for the Legendre 
    # polynomials only, as they have already been checked, later polynomials 
    # can then rely on this method to work.
    
    assert_array_almost_equal(sqnorm_legendre(0), 1)
    h1 = [sqnorm_from_rc(rc_legendre, i) for i in range(7)]
    h2 = [sqnorm_legendre(i) for i in range(7)]
    assert_array_almost_equal(h1, h2)


def test_sqnorm_hermite():
    # for hermite
    assert_array_almost_equal(sqnorm_stoch_hermite(0), 1)
    h1 = [sqnorm_from_rc(rc_stoch_hermite, i) for i in range(7)]
    h2 = [sqnorm_stoch_hermite(i) for i in range(7)]
    assert_array_almost_equal(h1, h2)


def test_sqnorm_jacobi():
    rc_jac = lambda n: rc_jacobi(n, 0, 2)
    h1 = [sqnorm_from_rc(rc_jac, i) for i in range(7)]
    h2 = [sqnorm_jacobi(i, 0, 2) for i in range(7)]
    assert_array_almost_equal(h1, h2)

# test the structure coefficient stuff

def test_stc_hermite():
    assert_equal(stc_stoch_hermite(0,0,0), 1)
    assert_equal(stc_stoch_hermite(1,1,1), 0)
    assert_equal(stc_stoch_hermite(-1,0,0), 0)
    assert_equal(stc_stoch_hermite(0,-1,0), 0)
    assert_equal(stc_stoch_hermite(0,0,-2), 0)
    assert_equal(stc_stoch_hermite(2,3,5,True), 120)
    assert_equal(stc_stoch_hermite(2,3,5), 1)
    assert_equal(stc_stoch_hermite(2,1,4), 0)
    assert_equal(stc_stoch_hermite(3,1,4,True), 24)
    assert_equal(stc_stoch_hermite(7,5,8,True), 16934400)
    assert_equal(stc_stoch_hermite(7,5,8,False), 420)
    
    c=stc_stoch_hermite
    n=sqnorm_stoch_hermite
    x = np.poly1d([1, 0])
    P = compute_poly(rc_stoch_hermite, 5, x)
    p1=P[2]*P[3]
    p2=sum([c(2,3,i)*P[i] for i in xrange(6)])
    assert_array_equal(p1, p2)

# Make sure the support functions work.

def test_rc3_to_norm():
    # make sure the function to convert recurrences of normalised 
    # polynomials to the "standard" 3 coefficient form works, so that 
    # it can be used with compute_poly 
    x = np.poly1d([1, 0])
    rc3_norm_legendre = rc_norm_to_rc3(rc_norm_legendre)
    P1 = compute_poly(rc3_norm_legendre, 4, x)
    P2 = compute_poly(rc_legendre, 4, x)
    hs = [sqnorm_legendre(i) ** 0.5 for i in range(5)]

    assert_array_almost_equal(P1[0] * hs[0], P2[0])
    assert_array_almost_equal(P1[1] * hs[1], P2[1])
    assert_array_almost_equal(P1[2] * hs[2], P2[2])
    assert_array_almost_equal(P1[3] * hs[3], P2[3])
    assert_array_almost_equal(P1[4] * hs[4], P2[4])

def test_normalise_rc():
    # make sure the function to normalise a recurrence works correctly, 
    # by comparing the analytic recurrence for the normalised legendre polys
    # with the numerically normalised (given the norm explicitly and implicitly 
    # using sqnorm_from_rc) 
    rc_1 = rc_norm_to_rc3(rc_norm_legendre)
    rc_2 = normalise_rc(rc_legendre)
    rc_3 = normalise_rc(rc_legendre, sqnorm_legendre)

    assert_array_almost_equal(rc_1(0), rc_2(0))
    assert_array_almost_equal(rc_1(1), rc_2(1))
    assert_array_almost_equal(rc_1(2), rc_2(2))
    assert_array_almost_equal(rc_1(3), rc_2(3))
    assert_array_almost_equal(rc_1(4), rc_2(4))
    assert_array_almost_equal(rc_1(1), rc_3(1))
    assert_array_almost_equal(rc_1(2), rc_3(2))
    assert_array_almost_equal(rc_1(3), rc_3(3))
    assert_array_almost_equal(rc_1(4), rc_3(4))

def test_rc_shift_scale():
    # make sure shifting and scaling works for recurrences
    x = np.poly1d([1.0, 0])
    rc_1 = rc_legendre
    rc_2 = rc_shift_scale(rc_legendre, 2, 3)
    P1 = compute_poly(rc_1, 5, (x - 2.0) / 3.0)
    P2 = compute_poly(rc_2, 5, x)
    assert_array_almost_equal(P1[0], P2[0])
    assert_array_almost_equal(P1[3], P2[3])
    assert_array_almost_equal(P1[5], P2[5])
    P1 = compute_poly(rc_1, 5, x)
    P2 = compute_poly(rc_2, 5, 3 * x + 2)
    assert_array_almost_equal(P1[0], P2[0])
    assert_array_almost_equal(P1[3], P2[3])
    assert_array_almost_equal(P1[5], P2[5])

def test_rc_window_trans():
    # make sure the window transformation works for recurrences
    x = np.poly1d([1.0, 0])
    rc_1 = rc_stoch_hermite
    P1 = compute_poly(rc_1, 5, x)
    # just scale
    rc_2 = rc_window_trans(rc_stoch_hermite, (-1, 1), (-2, 2))
    P2 = compute_poly(rc_2, 5, x)
    assert_almost_equal(P2[5](-2), P1[5](-1))
    assert_almost_equal(P2[5](0), P1[5](0))
    assert_almost_equal(P2[5](1), P1[5](0.5))
    assert_almost_equal(P2[5](2), P1[5](1))
    # just shift
    rc_2 = rc_window_trans(rc_stoch_hermite, (-1, 1), (3, 5))
    P2 = compute_poly(rc_2, 5, x)
    assert_almost_equal(P2[5](3), P1[5](-1))
    assert_almost_equal(P2[5](4), P1[5](0))
    assert_almost_equal(P2[5](5), P1[5](1))
    # shift and scale
    rc_2 = rc_window_trans(rc_stoch_hermite, (-1, 1), (2, 6))
    P2 = compute_poly(rc_2, 5, x)
    assert_almost_equal(P2[5](2), P1[5](-1))
    assert_almost_equal(P2[5](4), P1[5](0))
    assert_almost_equal(P2[5](5), P1[5](0.5))
    assert_almost_equal(P2[5](6), P1[5](1))

def test_eval_clenshaw():
    # test the clenshaw algorithm for evaluating polynomials
    rc = rc_monomials
    x = np.poly1d([1, 0])
    assert_array_equal(eval_clenshaw(rc, [2], x), 2)
    assert_array_equal(eval_clenshaw(rc, [2, 3, 0.5], x),
                       2 + 3 * x + 0.5 * x ** 2)
    assert_array_equal(eval_clenshaw(rc, [2, 3, 0.5, 4], x),
                       2 + 3 * x + 0.5 * x ** 2 + 4 * x ** 3)

    rc = rc_legendre
    p = compute_poly(rc, 4, x)
    assert_array_equal(eval_clenshaw(rc, [3], x), inner(p, [3]))
    assert_array_equal(eval_clenshaw(rc, [3, 5], x), inner(p, [3, 5]))
    assert_array_equal(eval_clenshaw(rc, [3, 5, 7], x), inner(p, [3, 5, 7]))
    assert_array_equal(eval_clenshaw(rc, [3, 5, 7, 9], x),
                       inner(p, [3, 5, 7, 9]))

def test_eval_forsythe():
    # test the forythe algorithm for evaluating polynomials
    rc = rc_monomials
    x = np.poly1d([1, 0])
    assert_array_equal(eval_forsythe(rc, [2], x), 2)
    assert_array_equal(eval_forsythe(rc, [2, 3, 0.5], x),
                       2 + 3 * x + 0.5 * x ** 2)
    assert_array_equal(eval_forsythe(rc, [2, 3, 0.5, 4], x),
                       2 + 3 * x + 0.5 * x ** 2 + 4 * x ** 3)

    rc = rc_legendre
    p = compute_poly(rc, 4, x)
    assert_array_equal(eval_forsythe(rc, [3], x), inner(p, [3]))
    assert_array_equal(eval_forsythe(rc, [3, 5], x), inner(p, [3, 5]))
    assert_array_equal(eval_forsythe(rc, [3, 5, 7], x), inner(p, [3, 5, 7]))
    assert_array_equal(eval_forsythe(rc, [3, 5, 7, 9], x),
                       inner(p, [3, 5, 7, 9]))



test_main()
